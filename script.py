# -*- coding: utf-8 -*-
"""script

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Ij9bI5ZHczywkUADGPmYxIpEtkS3k1XK
"""

# -*- coding: utf-8 -*-
"""DWH_project_transformation_dag.py

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1FsUlXC_0tm3APOsEPbVLf6e7rnPkbHo3

# **Loading csv files into dataframes**
"""
file_path1 = '/mnt/c/Users/HP/Documents/Downloads/warehousing_files/doctors_org.csv'
file_path2 = '/mnt/c/Users/HP/Documents/Downloads/warehousing_files/patients_org.csv'
file_path3 = '/mnt/c/Users/HP/Documents/Downloads/warehousing_files/prescriptions_org.csv'
file_path4 = '/mnt/c/Users/HP/Documents/Downloads/warehousing_files/rooms_org.csv'
file_path5 = '/mnt/c/Users/HP/Documents/Downloads/warehousing_files/medical_records_org.csv'
file_path6 = '/mnt/c/Users/HP/Documents/Downloads/warehousing_files/ambulance_logs_org.csv'
file_path7 = '/mnt/c/Users/HP/Documents/Downloads/warehousing_files/dirty_medical_record_medicine_df_org.csv'
file_path8 = '/mnt/c/Users/HP/Documents/Downloads/warehousing_files/medicines_org.csv'
file_path9 = '/mnt/c/Users/HP/Documents/Downloads/warehousing_files/room_assignments_org.csv'
file_path10 = '/mnt/c/Users/HP/Documents/Downloads/warehousing_files/appointments_org.csv'
file_path11 = '/mnt/c/Users/HP/Documents/Downloads/warehousing_files/pharmacy_org.csv'
file_path12 = '/mnt/c/Users/HP/Documents/Downloads/warehousing_files/ambulances_org.csv'
file_path13 = '/mnt/c/Users/HP/Documents/Downloads/warehousing_files/billing_org.csv'

import pandas as pd

doctor_df = pd.read_csv(file_path1)
patient_df = pd.read_csv(file_path2)
prescription_df = pd.read_csv(file_path3)
room_df = pd.read_csv(file_path4)
medical_record_df = pd.read_csv(file_path5)
ambulance_log_df = pd.read_csv(file_path6)
medical_record_medicine_df = pd.read_csv(file_path7)
medicine_df = pd.read_csv(file_path8)
room_assignment_df = pd.read_csv(file_path9)
appointment_df = pd.read_csv(file_path10)
pharmacy_df = pd.read_csv(file_path11)
ambulance_df = pd.read_csv(file_path12)
billing_df = pd.read_csv(file_path13)


"""# **Viewing df heads to confirm successful load**"""

doctor_df.head()

patient_df.head()

prescription_df.head()

room_df.head()

medical_record_df.head()

ambulance_log_df.head()

ambulance_df.head()

medical_record_medicine_df.head()

medicine_df.head()

room_assignment_df.head()

appointment_df.head()

pharmacy_df.head()

billing_df.head()

prescription_df.head()

"""# **Checking and Dropping duplicate rows**"""

# Counting duplicate values in each df

def count_duplicate_rows(df, df_name):
    duplicates = df[df.duplicated(keep=False)]
    num_duplicates = len(duplicates)
    if num_duplicates > 0:
        print(f"Number of duplicate rows in {df_name}: {num_duplicates}")
        #print(duplicates) #Uncomment if you want to see the actual duplicate rows.
    else:
        print(f"No duplicate rows found in {df_name}")


dataframes = {
    'doctor_df': doctor_df,
    'patient_df': patient_df,
    'prescription_df': prescription_df,
    'room_df': room_df,
    'medical_record_df': medical_record_df,
    'ambulance_log_df': ambulance_log_df,
    'ambulance_df': ambulance_df,
    'medical_record_medicine_df': medical_record_medicine_df,
    'medicine_df': medicine_df,
    'room_assignment_df': room_assignment_df,
    'appointment_df': appointment_df,
    'pharmacy_df': pharmacy_df,
    'billing_df': billing_df
}

for df_name, df in dataframes.items():
    count_duplicate_rows(df, df_name)

# drop duplicates from necessary dfs

doctor_df = doctor_df.drop_duplicates()
patient_df = patient_df.drop_duplicates()
prescription_df = prescription_df.drop_duplicates()
room_df = room_df.drop_duplicates()
medical_record_df = medical_record_df.drop_duplicates()
ambulance_log_df = ambulance_log_df.drop_duplicates()
medicine_df = medicine_df.drop_duplicates()
appointment_df = appointment_df.drop_duplicates()
ambulance_df = ambulance_df.drop_duplicates()
billing_df = billing_df.drop_duplicates()

dataframes = {
    'doctor_df': doctor_df,
    'patient_df': patient_df,
    'prescription_df': prescription_df,
    'room_df': room_df,
    'medical_record_df': medical_record_df,
    'ambulance_log_df': ambulance_log_df,
    'ambulance_df': ambulance_df,
    'medical_record_medicine_df': medical_record_medicine_df,
    'medicine_df': medicine_df,
    'room_assignment_df': room_assignment_df,
    'appointment_df': appointment_df,
    'pharmacy_df': pharmacy_df,
    'billing_df': billing_df
}

for df_name, df in dataframes.items():
    count_duplicate_rows(df, df_name)

"""# **Handling missing values and formatting issues**

**Handling missing vals and other issues for doctors df**
"""

# Checking missing vals for doctor df

doctor_df.isnull().sum()

# Function to intake a df and its column and replace missing vals with N/A

def replace_missing_with_na(df, column_name):

    if column_name in df.columns:
        df_copy = df.copy()
        # Condition to check for both null and "nan" values
        df_copy[column_name] = df_copy[column_name].fillna('N/A')
        # Fill "nan" string values with "N/A"
        df_copy[column_name] = df_copy[column_name].replace('nan', 'N/A')
        return df_copy
    else:
        print(f"Warning: Column '{column_name}' not found in DataFrame.")
        return df

# Hnadling missing contact numbers in doctor df

doctor_df = replace_missing_with_na(doctor_df, 'Contact No')
doctor_df.isnull().sum()

# Handling missing emails in doctor df

doctor_df = replace_missing_with_na(doctor_df, 'Email')
doctor_df.isnull().sum()

doctor_df['Position'].unique()

doctor_df.isnull().sum()

# Function that intakes a df and a column from the df and removes all special characters from the rows of that column

import re

def remove_special_characters(df, column_name):
  if column_name not in df.columns:
    print(f"Warning: Column '{column_name}' not found in DataFrame.")
    return df

  df_copy = df.copy()

  df_copy[column_name] = df_copy[column_name].astype(str).apply(lambda x: re.sub(r'[!@#$%^&*()_+=\[\]{}|:;<>,.?/~`]', '', x))
  return df_copy

# Function to handle special characters in numerical cols

def remove_special_characters_num(df, column_name):

  if column_name not in df.columns:
    print(f"Warning: Column '{column_name}' not found in DataFrame.")
    return df

  df_copy = df.copy()

  # Function to process each value
  def process_value(value):
      # Extract digits using regex
      digits = re.findall(r'\d', str(value))
      # Re-concatenate digits
      return ''.join(digits) if digits else value

  # Apply the function to the column
  df_copy[column_name] = df_copy[column_name].apply(process_value)
  return df_copy

doctor_df = remove_special_characters(doctor_df, 'Position')
doctor_df['Position'].unique()

doctor_df['Specialty'].unique()

doctor_df = remove_special_characters(doctor_df, 'Position')
doctor_df['Position'].unique()

doctor_df.isnull().sum()

# Function that replaces missing values/nan values in column B based on the modal value of column B for the corresponding value in column A

def fill_missing_with_modal(df, column_a, column_b):

    # Create a copy of the DataFrame to avoid modifying the original
    df_copy = df.copy()

    # Group by column_a and get the modal value for column_b
    modal_values = df_copy.groupby(column_a)[column_b].agg(lambda x: x.mode()[0] if not x.mode().empty else None)

    # Fill missing values in column_b based on the modal value for each group
    for group, modal_value in modal_values.items():
        # Condition to check for both null and "nan" values
        df_copy.loc[(df_copy[column_a] == group) & (df_copy[column_b].isnull() | (df_copy[column_b] == 'nan')), column_b] = modal_value

    return df_copy

doctor_df = fill_missing_with_modal(doctor_df, 'Specialty', 'Position')
doctor_df.isnull().sum()

doctor_df = remove_special_characters(doctor_df, 'Position')
doctor_df['Position'].unique()

doctor_df.dtypes

# Function to convert a columns data type to date

def convert_to_date(df, column_name, format='%Y-%m-%d'):
    if column_name in df.columns:
        try:
            # Convert to datetime with errors='raise'
            df[column_name] = pd.to_datetime(df[column_name], format=format, errors='raise')
            # Convert to date only for valid dates
            df[column_name] = df[column_name].dt.date
        except ValueError:
            # Skip invalid dates and do nothing
            pass
    else:
        print(f"Warning: Column '{column_name}' not found in DataFrame.")
    return df

doctor_df = convert_to_date(doctor_df, 'Started At')
doctor_df.dtypes

doctor_df.head()

# Code to count the values in a date column where format isnt xxxx-xx-xx

def count_invalid_dates(df, column_name):

    # Regular expression to match 'YYYY-MM-DD' format
    date_pattern = r'^\d{4}-\d{2}-\d{2}$'

    # Filter out 'N/A' values before counting
    filtered_df = df[df[column_name] != 'N/A']

    # Count values in the filtered DataFrame that don't match the pattern
    invalid_dates_count = filtered_df[~filtered_df[column_name].astype(str).str.match(date_pattern)].shape[0]

    return invalid_dates_count

invalid_count = count_invalid_dates(doctor_df, 'Started At')
print(f"Number of invalid dates in 'Started At' column: {invalid_count}")

# Function to fix invalid dates

def convert_invalid_dates(df, column_name):

    date_pattern = r'^\d{4}-\d{2}-\d{2}$'
    # Filter out 'N/A' values before checking for invalid dates
    invalid_dates = df[~df[column_name].astype(str).str.match(date_pattern) & (df[column_name] != 'N/A')][column_name]

    for index, value in invalid_dates.items():
        try:
            # Try to convert using pandas to_datetime (handles various formats)
            converted_date = pd.to_datetime(value, errors='raise').strftime('%Y-%m-%d')  # Convert to datetime
            df.loc[index, column_name] = pd.to_datetime(converted_date).date()  # Convert to date
        except ValueError:
            try:
                # If pandas conversion fails, try extracting numbers and formatting
                numbers = re.findall(r'\d+', str(value))
                if len(numbers) >= 3:
                    year = numbers[0][:4]
                    month = numbers[1][:2] if len(numbers[1]) >= 2 else numbers[1].zfill(2)
                    day = numbers[2][:2] if len(numbers[2]) >= 2 else numbers[2].zfill(2)
                    converted_date = f"{year}-{month}-{day}"
                    df.loc[index, column_name] = pd.to_datetime(converted_date).date()  # Convert to date
                else:
                    print(f"Warning: Could not extract enough numbers from '{value}' at index {index}")
            except (ValueError, TypeError) as e:
                print(f"Warning: Error processing '{value}' at index {index}: {e}")

    return df

doctor_df = convert_invalid_dates(doctor_df, 'Started At')
invalid_count = count_invalid_dates(doctor_df, 'Started At')
print(f"Number of invalid dates in 'Started At' column: {invalid_count}")

doctor_df = convert_to_date(doctor_df, 'Started At')
doctor_df.dtypes

doctor_df.head()

# Function to count rows with special characters

def count_special_characters(df, column_name, special_characters="!@#$%^&*()_+=\[\]{}|:;<>,.?/~-`"):

    # Create a pattern to match any of the special characters
    pattern = f"[{re.escape(special_characters)}]"

    # Filter out rows with "N/A" values
    filtered_df = df[df[column_name] != "N/A"]

    # Count rows where the column contains any special character
    count = filtered_df[filtered_df[column_name].astype(str).str.contains(pattern, na=False)].shape[0]

    return count

special_char_count = count_special_characters(doctor_df, 'Contact No')
print(f"Number of rows with special characters: {special_char_count}")

doctor_df = remove_special_characters_num(doctor_df, 'Contact No')

special_char_count = count_special_characters(doctor_df, 'Contact No')
print(f"Number of rows with special characters: {special_char_count}")

doctor_df.head()

doctor_df.shape

# Checking for duplicate vals in the Doctor Id col Of doctor_df

duplicate_doctor_ids = doctor_df[doctor_df.duplicated(subset=['Doctor Id'], keep=False)]
duplicate_doctor_ids

# Again dropping duplicate rows after cleaning for doctor_df

doctor_df = doctor_df.drop_duplicates()
duplicate_doctor_ids = doctor_df[doctor_df.duplicated(subset=['Doctor Id'], keep=False)]
duplicate_doctor_ids

"""**Handling missing vals and other issues for patients df**"""

# Checking missing vals for patient df

patient_df.isnull().sum()

# Handling missing vals for patient address, blood type and email

patient_df = replace_missing_with_na(patient_df, 'email')
patient_df = replace_missing_with_na(patient_df, 'address')
patient_df = replace_missing_with_na(patient_df, 'blood type')
patient_df.isnull().sum()

# Checking for invalid date formats in patient df

invalid_count = count_invalid_dates(patient_df, 'dob')
print(f"Number of invalid dates in 'dob' column: {invalid_count}")

patient_df = convert_to_date(patient_df, 'dob')
patient_df.dtypes

# Handling invalid date format issues

patient_df = convert_invalid_dates(patient_df, 'dob')
invalid_count = count_invalid_dates(patient_df, 'dob')
print(f"Number of invalid dates in 'dob' column: {invalid_count}")

patient_df.head()

# Function to check invalid phone number formats

def count_invalid_contact_numbers(df, column_name):

    # Regular expression to match the desired format
    contact_pattern = r'^\d{3}-\d{3}-\d{4}$'

    # Get invalid contact numbers
    invalid_contacts = df[~df[column_name].astype(str).str.match(contact_pattern)][column_name]

    # Count invalid contact numbers
    invalid_count = invalid_contacts.shape[0]

    return invalid_count

invalid_count = count_invalid_contact_numbers(patient_df, 'contact no')
print(f"Number of invalid contact numbers: {invalid_count}")

patient_df = remove_special_characters_num(patient_df, 'contact no')

special_char_count = count_special_characters(patient_df, 'contact no')
print(f"Number of rows with special characters: {special_char_count}")

patient_df.head()

# Checking for duplicate vals in the Patient ID in patient df

duplicate_patient_ids = patient_df[patient_df.duplicated(subset=['Patient id'], keep=False)]
duplicate_patient_ids

# Handling duplicates for patient df

patient_df = patient_df.drop_duplicates()
duplicate_patient_ids = patient_df[patient_df.duplicated(subset=['Patient id'], keep=False)]
duplicate_patient_ids

patient_df.shape

"""**Handling missing vals and other issues for prescription df**

---


"""

prescription_df.head()

'''# Checking for invalid date formats in prescription df

invalid_count = count_invalid_dates(prescription_df, 'Prescription date')
print(f"Number of invalid dates in 'Prescription date' column: {invalid_count}")'''

'''prescription_df = convert_to_date(prescription_df, 'Prescription date')
prescription_df.dtypes'''

'''# Handling invalid date format issues

prescription_df = convert_invalid_dates(prescription_df, 'Prescription date')
invalid_count = count_invalid_dates(prescription_df, 'Prescription date')
print(f"Number of invalid dates in 'Prescription date' column: {invalid_count}")'''

special_char_count = count_special_characters(prescription_df, 'Medication name')
print(f"Number of rows with special characters: {special_char_count}")

special_char_count = count_special_characters(prescription_df, 'Frequency')
print(f"Number of rows with special characters: {special_char_count}")

prescription_df = remove_special_characters(prescription_df, 'Frequency')
special_char_count = count_special_characters(prescription_df, 'Frequency')
print(f"Number of rows with special characters: {special_char_count}")

prescription_df['Frequency'].unique()

# Handling missing vals for frequency

prescription_df = replace_missing_with_na(prescription_df, 'Frequency')
prescription_df['Frequency'].unique()

prescription_df.isnull().sum()

prescription_df['Dosage'].unique()

prescription_df = replace_missing_with_na(prescription_df, 'Dosage')
prescription_df.isnull().sum()

prescription_df['Dosage'].unique()

prescription_df.head()

"""**Handling missing vals and other issues for medical records df**

---


"""

medical_record_df.head()

medical_record_df = replace_missing_with_na(medical_record_df, 'Treatment')
medical_record_df.isnull().sum()

medical_record_df['Diagnosis'].unique()

# Function to fix diagnoses column issues

def clean_diagnosis_column(df, column_name):

    if column_name not in df.columns:
        print(f"Warning: Column '{column_name}' not found in DataFrame.")
        return df

    df_copy = df.copy()

    def clean_text(text):
        # Remove text within parentheses
        text = re.sub(r'\(.*?\)', '', str(text))
        # Remove special characters
        text = re.sub(r'[!@#$%^&*()_+=\[\]{}|:;<>,.?/~`-]', '', text)  # Updated pattern
        return text.strip()

    df_copy[column_name] = df_copy[column_name].apply(clean_text)
    return df_copy

# Accessing the diagnoses column
medical_record_df = clean_diagnosis_column(medical_record_df, 'Diagnosis')
medical_record_df['Diagnosis'].unique()

# Create mapping dictionary
diagnosis_mapping = {
    'Type 2 Diabetes': 'Type 2 Diabetes',
    'Type 2 D': 'Type 2 Diabetes',
    'Type 2 Di': 'Type 2 Diabetes',
    'Type 2 Diabet': 'Type 2 Diabetes',
    'Type': 'Type 2 Diabetes',

    'Hyperlipidemia': 'Hyperlipidemia',
    'Hyperlipidemia E785': 'Hyperlipidemia',
    'Hype': 'Hyperlipidemia',
    'Hyp': 'Hyperlipidemia',

    'UTI': 'UTI',
    'UTI 90': 'UTI',
    'U': 'UTI',
    'UTI 390': 'UTI',

    'Major Depressive Disorder': 'Major Depressive Disorder',
    'Major': 'Major Depressive Disorder',
    'Major Depr': 'Major Depressive Disorder',

    'COVID19': 'COVID-19',
    'COVID19 071': 'COVID-19',
    'COVID1': 'COVID-19',

    'Asthma': 'Asthma',
    'As': 'Asthma',
    'Ast': 'Asthma',

    'Hypertension': 'Hypertension',
    'Hypertens': 'Hypertension',

    'Back Pain': 'Back Pain',
    'Back Pain M545': 'Back Pain',

    'Migraine': 'Migraine',
    'Mi': 'Migraine',
    'Migraine G43909': 'Migraine',

    'Acute Bronchitis': 'Acute Bronchitis',
    'Acute Br': 'Acute Bronchitis',
    'Ac': 'Acute Bronchitis',
    'Acute Bro': 'Acute Bronchitis',

    '': None,
}

# Apply mapping to the Diagnosis column
medical_record_df['Diagnosis'] = medical_record_df['Diagnosis'].replace(diagnosis_mapping)
medical_record_df['Diagnosis'].unique()

def map_diagnosis(text):
    if pd.isna(text):
        return None
    text = text.lower()
    if 'type 2 di' in text:
        return 'Type 2 Diabetes'
    elif 'hyperlip' in text:
        return 'Hyperlipidemia'
    elif 'uti' in text:
        return 'UTI'
    elif 'major dep' in text or 'majo' in text:
        return 'Major Depressive Disorder'
    elif 'covid' in text or 'co' in text:
        return 'COVID-19'
    elif 'asthma' in text or 'asth' in text:
        return 'Asthma'
    elif 'hypertens' in text or 'hyp' in text:
        return 'Hypertension'
    elif 'back pain' in text or 'bac' in text or text == 'back':
        return 'Back Pain'
    elif 'migraine' in text or 'migra' in text or 'mig' in text or text == 'mi':
        return 'Migraine'
    elif 'acute bron' in text or 'bro' in text or 'acu' in text or text == 'ac':
        return 'Acute Bronchitis'
    else:
        return text  # or None to mark unmapped

medical_record_df['Diagnosis'] = medical_record_df['Diagnosis'].apply(map_diagnosis)
# Create mapping dictionary
diagnosis_mapping = {
    'h': 'Hyperlipidemia',
    'c': 'COVID-19',

    '': None,
}

# Apply mapping to the Diagnosis column
medical_record_df['Diagnosis'] = medical_record_df['Diagnosis'].replace(diagnosis_mapping)
medical_record_df['Diagnosis'].unique()

medical_record_df.isnull().sum()

medical_record_df = replace_missing_with_na(medical_record_df, 'Diagnosis')
medical_record_df.isnull().sum()

medical_record_df = remove_special_characters(medical_record_df, 'Treatment')
medical_record_df['Treatment'].unique()

medical_record_df = replace_missing_with_na(medical_record_df, 'Treatment')
medical_record_df.isnull().sum()

appointment_df.head()

import pandas as pd

# Sample merge to find matching appointment IDs
merged_df = medical_record_df.merge(
    appointment_df[['Appointment id', 'Patient id', 'Doctor id']],
    how='left',
    left_on=['Patient id', 'Doctor id'],
    right_on=['Patient id', 'Doctor id'],
    suffixes=('', '_from_appointments')
)

# Fill missing appointment IDs using the matched ones
merged_df['Appointment id'] = merged_df['Appointment id'].fillna(merged_df['Appointment id_from_appointments'])

# Drop the helper column if no longer needed
merged_df = merged_df.drop(columns=['Appointment id_from_appointments'])

medical_record_df_withoutna = merged_df

medical_record_df_withoutna.isnull().sum()

"""**Handling missing vals and other issues for appointments df**

"""

appointment_df.head()

appointment_df = replace_missing_with_na(appointment_df, 'Purpose')
appointment_df = replace_missing_with_na(appointment_df, 'Appointment time')
appointment_df = replace_missing_with_na(appointment_df, 'Status')
appointment_df.isnull().sum()

# Checking for invalid date formats in appointment df

invalid_count = count_invalid_dates(appointment_df, 'Appointment date')
print(f"Number of invalid dates in 'Appointment date' column: {invalid_count}")

appointment_df = convert_to_date(appointment_df, 'Appointment date')
appointment_df.dtypes

appointment_df = convert_invalid_dates(appointment_df, 'Appointment date')
invalid_count = count_invalid_dates(appointment_df, 'Appointment date')
print(f"Number of invalid dates in 'Appointment date' column: {invalid_count}")

appointment_df['Status'].unique()

appointment_df = remove_special_characters(appointment_df, 'Status')
appointment_df['Status'].unique()

appointment_df['Purpose'].unique()

appointment_df = remove_special_characters(appointment_df, 'Purpose')
appointment_df['Purpose'].unique()

# Handling duplicates for appointment df

duplicate_appointment_ids = appointment_df[appointment_df.duplicated(subset=['Appointment id'], keep=False)]
duplicate_appointment_ids

# Handling duplicates for appointment df

appointment_df = appointment_df.drop_duplicates()
duplicate_appointment_ids = appointment_df[appointment_df.duplicated(subset=['Appointment id'], keep=False)]
duplicate_appointment_ids

appointment_df['Purpose'] = appointment_df['Purpose'].replace('NA', 'N/A')
appointment_df['Purpose'].unique()

appointment_df['Status'] = appointment_df['Status'].replace('NA', 'N/A')
appointment_df['Status'].unique()

"""**Handling missing vals and other issues for medicines df**

"""

medicine_df.head()

medicine_df = remove_special_characters(medicine_df, 'Name')
medicine_df['Name'].unique()

medicine_df = remove_special_characters(medicine_df, 'Brand')
medicine_df['Brand'].unique()

# Checking duplicates for medicine df

duplicate_medicine_ids = medicine_df[medicine_df.duplicated(subset=['Medicine id'], keep=False)]
duplicate_medicine_ids

# Handling duplicates for medicine df

medicine_df = medicine_df.drop_duplicates()
duplicate_medicine_ids = medicine_df[medicine_df.duplicated(subset=['Medicine id'], keep=False)]
duplicate_medicine_ids

"""**Handling missing vals and other issues for billing df**

"""

billing_df.head()

# Checking for invalid date formats in billing df

invalid_count = count_invalid_dates(billing_df, 'Payment date')
print(f"Number of invalid dates in 'Payment date' column: {invalid_count}")

billing_df = convert_to_date(billing_df, 'Payment date')
billing_df.dtypes

billing_df = replace_missing_with_na(billing_df, 'Payment date')
billing_df.isnull().sum()

billing_df = convert_invalid_dates(billing_df, 'Payment date')
invalid_count = count_invalid_dates(billing_df, 'Payment date')
print(f"Number of invalid dates in 'Payment date' column: {invalid_count}")

billing_df.isnull().sum()

billing_df = replace_missing_with_na(billing_df, 'Insurance provider')
billing_df.isnull().sum()

# Checking duplicates for billing df

duplicate_billing_ids = billing_df[billing_df.duplicated(subset=['Bill id'], keep=False)]
duplicate_billing_ids

# Drop duplicates based on the 'Bill id' column
billing_df = billing_df.drop_duplicates(subset=['Bill id'])

# Check for duplicate 'Bill id' values again to confirm
duplicate_billing_ids = billing_df[billing_df.duplicated(subset=['Bill id'], keep=False)]
duplicate_billing_ids

pharmacy_df = pd.read_csv(file_path11)
pharmacy_df.head()

pharmacy_df.isnull().sum()

# Compute mean and round to nearest whole number
mean_quantity = round(pharmacy_df['Quantity'].mean())

# Fill missing values in 'Quantity' with the rounded mean
pharmacy_df['Quantity'] = pharmacy_df['Quantity'].fillna(mean_quantity)

# Check for any remaining missing values
pharmacy_df.isnull().sum()

pharmacy_df['Quantity'] = pharmacy_df['Quantity'].astype(int)

medical_record_medicine_df.head()

medical_record_medicine_df.isnull().sum()

medical_record_df_withoutna.isnull().sum()

#medical_record_df_withoutna = medical_record_df_withoutna.dropna(subset=['Appointment id'])

medical_record_df_withoutna.isnull().sum()

"""Tables fixed so far, patients, doctors, prescriptions, appointments, medical records, medicines, pharamcy, billing, medical record df without na, medical record medicine

Dimension Tables

Patient Table
"""

patient_df.head()

DimPatientdf = patient_df.copy()
DimPatientdf.head()

"""Doctor Table"""

doctor_df.head()

DimDoctordf = doctor_df.copy()
DimDoctordf.head()

DimDoctordf.dtypes

import pandas as pd

# Assuming your DataFrame is called doctor_df

# Step 1: Convert 'Started At' to datetime
DimDoctordf['Started At'] = pd.to_datetime(doctor_df['Started At'])

# Step 2: Extract the starting year
DimDoctordf['Start Year'] = DimDoctordf['Started At'].dt.year

# Step 3: Calculate experience in years as of 2025
DimDoctordf['Experience Years'] = 2025 - DimDoctordf['Start Year']

DimDoctordf.head()

DimDoctordf = DimDoctordf.drop(columns=['Started At', 'Start Year'])
DimDoctordf.head()



"""Appointment Table"""





appointment_df.shape

DimAppointmentdf = appointment_df.copy()
DimAppointmentdf.head()

"""Note: Currently patient id, doctor id, and appointment date is kept in appointment table, but will be removed after the fact table is made"""

import numpy as np

# Convert to datetime (only for valid times)
DimAppointmentdf['Appointment time'] = pd.to_datetime(
    DimAppointmentdf['Appointment time'], format='%H:%M', errors='coerce'
)

# Extract hour from appointment time
DimAppointmentdf['Appointment_Hour'] = DimAppointmentdf['Appointment time'].dt.hour

# Function to classify part of day
def get_part_of_day(hour):
    if pd.isna(hour):
        return np.nan
    if 5 <= hour < 12:
        return 'Morning'
    elif 12 <= hour < 17:
        return 'Afternoon'
    elif 17 <= hour < 21:
        return 'Evening'
    else:
        return 'Night'

# Apply function
DimAppointmentdf['Appointment Part of Day'] = DimAppointmentdf['Appointment_Hour'].apply(get_part_of_day)

DimAppointmentdf.head()

# Count of NaT values in 'Appointment time' column
nat_count = DimAppointmentdf['Appointment time'].isna().sum()
print(f"Number of rows with NaT in 'Appointment time': {nat_count}")

DimAppointmentdf.shape

hour_mode = DimAppointmentdf['Appointment_Hour'].mode()[0]

# Fill missing values with mode
DimAppointmentdf['Appointment_Hour'] = DimAppointmentdf['Appointment_Hour'].fillna(hour_mode)

DimAppointmentdf.head()

DimAppointmentdf['Appointment_Hour'] = DimAppointmentdf['Appointment_Hour'].astype(int)

DimAppointmentdf.head()

DimAppointmentdf['Appointment Part of Day'] = DimAppointmentdf['Appointment_Hour'].apply(get_part_of_day)
DimAppointmentdf.head()

DimAppointmentdf = DimAppointmentdf.drop(columns=['Appointment time'])
DimAppointmentdf.head()

"""Prescription Table"""

medicine_df.head()

prescription_df.head()

albuterol_rows = medicine_df[medicine_df['Name'] == 'Albuterol']
print(albuterol_rows)

# Get sets of Record ids from both DataFrames
record_ids_1 = set(medical_record_df['Record id'])
record_ids_2 = set(medical_record_medicine_df['Record id'])

# Find the intersection
common_record_ids = record_ids_1.intersection(record_ids_2)

# Count of matching Record ids
print(f"Number of matching 'Record id' values: {len(common_record_ids)}")

DimPrescriptiondf = prescription_df.copy()

DimPrescriptiondf.rename(columns={'Duration (days)': 'Duration days'}, inplace=True)

DimPrescriptiondf.head()

pharmacy_df.head()

# Step 1: Merge prescriptions with pharmacy to get Medicine id
prescription_with_medicine = DimPrescriptiondf.merge(
    pharmacy_df[['Prescription id', 'Medicine id']],
    on='Prescription id',
    how='left'
)

# Step 2: Merge with medicine_df to get Brand and Type
prescription_with_medicine = prescription_with_medicine.merge(
    medicine_df[['Medicine id', 'Brand', 'Type']],
    on='Medicine id',
    how='left'
)

# Optional: Rename columns if needed
# prescription_with_medicine.rename(columns={'Brand': 'Medication Brand', 'Type': 'Medication Type'}, inplace=True)

# Final result
DimPrescriptiondf1 = prescription_with_medicine
DimPrescriptiondf1.head()

DimPrescriptiondf = DimPrescriptiondf1.copy()
DimPrescriptiondf.head()

"""Date"""

import pandas as pd

# Ensure 'Appointment date' is datetime
DimAppointmentdf['Appointment date'] = pd.to_datetime(DimAppointmentdf['Appointment date'])

from datetime import datetime, timedelta

# Define date range: from 2 years ago until today
start_date = datetime.today() - timedelta(days=2*365)
end_date = datetime.today()

# Create date range
date_range = pd.date_range(start=start_date, end=end_date)

# Define function to map month to season
def get_season(month):
    if month in [12, 1, 2]:
        return 'Winter'
    elif month in [3, 4, 5]:
        return 'Spring'
    elif month in [6, 7, 8]:
        return 'Summer'
    else:  # 9, 10, 11
        return 'Autumn'

# Create DimDatedf
DimDatedf = pd.DataFrame({
    'Date id': range(1, len(date_range) + 1),
    'Date': date_range,
    'Year': date_range.year,
    'Quarter': date_range.quarter,
    'Month': date_range.month,
    'Day': date_range.day,
})

# Add Season column
DimDatedf['Season'] = DimDatedf['Month'].apply(get_season)

# Convert full datetime to just date (YYYY-MM-DD)
DimDatedf['Date'] = DimDatedf['Date'].dt.date


# Preview
DimDatedf.head()

"""Medical Record"""

DimMedicalRecorddf = medical_record_df_withoutna.copy()
DimMedicalRecorddf.head()

billing_df.head()

# Merge billing info into DimMedicalRecorddf using 'Appointment id'
DimMedicalRecorddf = DimMedicalRecorddf.merge(
    billing_df[['Appointment id', 'Payment status', 'Insurance provider']],
    on='Appointment id',
    how='left'  # Use 'left' to keep all medical records even if billing info is missing
)

# Preview the updated DataFrame
DimMedicalRecorddf.head()

# Merge DimMedicalRecorddf's Payment status into DimAppointmentdf based on Appointment id
DimAppointmentdf = DimAppointmentdf.merge(
    DimMedicalRecorddf[['Appointment id', 'Payment status']],
    on='Appointment id',
    how='left'  # Use a left merge to keep all appointments
)

# Preview the updated DimAppointmentdf
DimAppointmentdf.head()

# Drop the 'Payment status' column from DimMedicalRecorddf
DimMedicalRecorddf = DimMedicalRecorddf.drop(columns=['Payment status'])

# Preview the updated DataFrame
DimMedicalRecorddf.head()

"""Fact Table"""

DimAppointmentdf.head()

DimPrescriptiondf.head()

# Initialize FactPrescriptiondf directly with selected columns
FactPrescriptiondf = DimPrescriptiondf[['Prescription id','Appointment id', 'Patient id', 'Doctor Id', 'Medicine id', 'Dosage', 'Duration days']].copy()

# Check the result
FactPrescriptiondf.head()

pharmacy_df.head()

# Merge using both Prescription id and Medicine id to avoid duplicates
FactPrescriptiondf = FactPrescriptiondf.merge(
    pharmacy_df[['Prescription id', 'Medicine id', 'Quantity']],
    on=['Prescription id', 'Medicine id'],
    how='left'
)

# Rename the column
FactPrescriptiondf.rename(columns={'Quantity': 'Medicine Quantity'}, inplace=True)

# Check the result
FactPrescriptiondf.head()

# Check uniqueness of Medicine id in medicine_df
if medicine_df['Medicine id'].is_unique:
    # Step 1: Merge to bring Price from medicine_df
    FactPrescriptiondf = FactPrescriptiondf.merge(
        medicine_df[['Medicine id', 'Price']],
        on='Medicine id',
        how='left'
    )

    # Step 2: Calculate total amount
    FactPrescriptiondf['Medicine_Total_Amt'] = FactPrescriptiondf['Price'] * FactPrescriptiondf['Medicine Quantity']

    # Optional: Drop 'Price' column if not needed
    FactPrescriptiondf.drop(columns=['Price'], inplace=True)
else:
    print("Warning: Medicine id is not unique in medicine_df. Merge might cause duplicates.")

# View result
FactPrescriptiondf.head()

# Merge to bring Total amount from billing_df
FactPrescriptiondf = FactPrescriptiondf.merge(
    billing_df[['Appointment id', 'Total amount']],
    on='Appointment id',
    how='left'
)

# Rename the column for clarity
FactPrescriptiondf.rename(columns={'Total amount': 'Appointment Amount'}, inplace=True)

# View result
FactPrescriptiondf.head()

FactPrescriptiondf.shape

# Count rows with duplicate combinations of 'Appointment id', 'Patient id', and 'Doctor Id'
duplicate_count = FactPrescriptiondf.duplicated(subset=['Appointment id', 'Patient id', 'Doctor Id'], keep=False).sum()

print(f"Number of rows with the same Appointment id, Patient id, and Doctor Id: {duplicate_count}")

FactPrescriptiondf1 = FactPrescriptiondf
FactPrescriptiondf1.head()

import pandas as pd
import re
import numpy as np

df = FactPrescriptiondf1.copy()
df['Dosage'] = df['Dosage'].astype(str)

# Replace "N/A" with NaN
df['Dosage'] = df['Dosage'].replace('N/A', pd.NA)

# Conversion helper function
def convert_to_mg(dosage):
    if pd.isna(dosage):
        return pd.NA
    dosage = dosage.strip().lower()

    # Match patterns like '90mcg', '90mcg/inh', '90 mcg/ml', etc.
    match = re.match(r"([\d\.]+)\s*mcg", dosage)
    if match:
        mcg_val = float(match.group(1))
        mg_val = mcg_val / 1000  # 1 mg = 1000 mcg
        return round(mg_val, 5)

    # Match already in mg
    match = re.match(r"([\d\.]+)\s*mg", dosage)
    if match:
        return round(float(match.group(1)), 5)

    # Try just numeric string
    try:
        return round(float(dosage), 5)
    except ValueError:
        return pd.NA  # Can't interpret the value

# Apply the conversion
df['Dosage_mg'] = df['Dosage'].apply(convert_to_mg)
# Function to get numeric mode per group
def get_numeric_mode(series):
    non_na_values = series.dropna()
    if non_na_values.empty:
        return pd.NA
    mode_vals = non_na_values.mode()
    for val in mode_vals:
        if pd.notna(val):
            return val
    return pd.NA

# Get mode mapping
mode_map = df.groupby('Medicine id')['Dosage_mg'].apply(get_numeric_mode)

# Fill missing Dosage_mg values
def fill_missing_dosage(row):
    if pd.isna(row['Dosage_mg']):
        return mode_map.get(row['Medicine id'], pd.NA)
    return row['Dosage_mg']

df['Dosage_mg'] = df.apply(fill_missing_dosage, axis=1)
FactPrescriptiondf1 = df

# Drop 'Dosage' column
FactPrescriptiondf1 = FactPrescriptiondf1.drop(columns=['Dosage'])

# Reorder columns: insert 'Dosage (mg)' at position 5 (6th column, index starts at 0)
cols = list(FactPrescriptiondf1.columns)
cols.remove('Dosage_mg')
cols.insert(5, 'Dosage_mg')  # insert at position 6

# Apply new column order
FactPrescriptiondf1 = FactPrescriptiondf1[cols]

FactPrescriptiondf1.head()

FactPrescriptiondf = FactPrescriptiondf1.copy()
FactPrescriptiondf.head()

FactPrescriptiondf.shape

DimAppointmentdf.head()

# Merge to copy 'Appointment Amount' from FactPrescriptiondf to DimAppointmentdf
DimAppointmentdf = DimAppointmentdf.merge(
    FactPrescriptiondf[['Appointment id', 'Appointment Amount']],
    on='Appointment id',
    how='left'  # Use a left merge to keep all appointments in DimAppointmentdf
)

# Display the updated DimAppointmentdf
DimAppointmentdf.head()

# Count duplicate rows in DimAppointmentdf
duplicate_rows_count = DimAppointmentdf.duplicated().sum()

print(f"Number of duplicate rows in DimAppointmentdf: {duplicate_rows_count}")

DimAppointmentdf.shape

# Drop duplicate rows from DimAppointmentdf
DimAppointmentdf = DimAppointmentdf.drop_duplicates()

# Optionally, verify that duplicates have been dropped by counting again
duplicate_rows_count_after_drop = DimAppointmentdf.duplicated().sum()
print(f"Number of duplicate rows in DimAppointmentdf after dropping: {duplicate_rows_count_after_drop}")

# Display the head of the DataFrame to see the result
DimAppointmentdf.shape

# Drop the 'Appointment Amount' column from FactPrescriptiondf
FactPrescriptiondf = FactPrescriptiondf.drop(columns=['Appointment Amount'])

# Display the updated DataFrame
FactPrescriptiondf.head()

# Count duplicate rows in DimAppointmentdf
duplicate_rows_count = DimAppointmentdf.duplicated().sum()

print(f"Number of duplicate rows in DimAppointmentdf: {duplicate_rows_count}")

DimMedicalRecorddf.shape

# Count duplicate rows in DimMedicalRecorddf
duplicate_rows_count_medical_record = DimMedicalRecorddf.duplicated().sum()
print(f"Number of duplicate rows in DimMedicalRecorddf: {duplicate_rows_count_medical_record}")

# Drop duplicate rows from DimMedicalRecorddf
DimMedicalRecorddf = DimMedicalRecorddf.drop_duplicates()

# Optionally, verify that duplicates have been dropped by counting again
duplicate_rows_count_medical_record_after_drop = DimMedicalRecorddf.duplicated().sum()
print(f"Number of duplicate rows in DimMedicalRecorddf after dropping: {duplicate_rows_count_medical_record_after_drop}")

# Display the head of the DataFrame to see the result
DimMedicalRecorddf.shape

DimPrescriptiondf.shape

# Count duplicate rows in DimPrescriptiondf
duplicate_rows_count_prescription = DimPrescriptiondf.duplicated().sum()
print(f"Number of duplicate rows in DimPrescriptiondf: {duplicate_rows_count_prescription}")

# Drop duplicate rows from DimPrescriptiondf
DimPrescriptiondf = DimPrescriptiondf.drop_duplicates()

# Optionally, verify that duplicates have been dropped by counting again
duplicate_rows_count_prescription_after_drop = DimPrescriptiondf.duplicated().sum()
print(f"Number of duplicate rows in DimPrescriptiondf after dropping: {duplicate_rows_count_prescription_after_drop}")

# Display the head of the DataFrame to see the result
DimPrescriptiondf.head()

DimPrescriptiondf.shape

# Merge appointment_df to FactPrescriptiondf to copy 'Appointment date' as 'Date'
FactPrescriptiondf = FactPrescriptiondf.merge(
    appointment_df[['Appointment id', 'Appointment date']],
    on='Appointment id',
    how='left'  # Use left merge to keep all prescriptions
)

# Rename the column to 'Date'
FactPrescriptiondf.rename(columns={'Appointment date': 'Date'}, inplace=True)

# Display the updated DataFrame
FactPrescriptiondf.head()

FactPrescriptiondf.isnull().sum()

# Convert the 'Date' column in FactPrescriptiondf to datetime objects for matching
# Convert both to datetime64[ns] and normalize time to midnight for accurate merge
FactPrescriptiondf['Date'] = pd.to_datetime(FactPrescriptiondf['Date']).dt.normalize()
DimDatedf['Date'] = pd.to_datetime(DimDatedf['Date'])  # No need to normalize since it's already date only
# Merge to bring Date id
FactPrescriptiondf = FactPrescriptiondf.merge(
    DimDatedf[['Date', 'Date id']],
    on='Date',
    how='left'
)

# Reorder 'Date id' to 6th position (index 5)
cols = FactPrescriptiondf.columns.tolist()
date_id_index = cols.index('Date id')
cols.insert(5, cols.pop(date_id_index))
FactPrescriptiondf = FactPrescriptiondf[cols]
FactPrescriptiondf.head()

FactPrescriptiondf = FactPrescriptiondf.dropna(subset=['Date id'])
if FactPrescriptiondf['Date id'].isnull().any():
    print("Warning: There are missing Date id values. Fill or drop them before converting.")
else:
    FactPrescriptiondf['Date id'] = FactPrescriptiondf['Date id'].astype(int)

# Display the updated DataFrame
FactPrescriptiondf.head()

FactPrescriptiondf = FactPrescriptiondf.drop(columns=['Date'])
FactPrescriptiondf.head()

"""Fixing ids for dimensions"""

cols_to_drop = ['Dosage', 'Duration days', 'Medicine id']
DimPrescriptiondf = DimPrescriptiondf.drop(columns=[col for col in cols_to_drop if col in DimPrescriptiondf.columns])
DimPrescriptiondf.head()

DimPatientdf.head()

DimDoctordf.head()

DimPrescriptiondf.head()

DimPrescriptiondf = DimPrescriptiondf.drop(columns=['Appointment id','Patient id','Doctor Id'])
DimPrescriptiondf.head()

DimMedicalRecorddf.head()

# Drop 'Medicine id' column
FactPrescriptiondf = FactPrescriptiondf.drop(columns=['Medicine id'])

# Merge to get 'Record id' from DimMedicalRecorddf using 'Appointment id'
FactPrescriptiondf = FactPrescriptiondf.merge(
    DimMedicalRecorddf[['Appointment id', 'Record id']],
    on='Appointment id',
    how='left'
)

# Rearrange columns to insert 'Record id' as the 5th column (index 4)
cols = list(FactPrescriptiondf.columns)
cols.remove('Record id')   # remove from end
cols.insert(4, 'Record id')  # insert at 5th position (index 4)

FactPrescriptiondf = FactPrescriptiondf[cols]


DimMedicalRecorddf = DimMedicalRecorddf.drop(columns=['Appointment id','Patient id','Doctor id'])
DimMedicalRecorddf.head()

DimDatedf.head()

DimAppointmentdf.head()

DimAppointmentdf = DimAppointmentdf.drop(columns=['Patient id','Doctor id'])
DimAppointmentdf.head()

FactPrescriptiondf.head()

# Function to standardize column names

import re

def standardize_column_names(df):
    # Remove all non-alphanumeric characters except underscores
    new_columns = [re.sub(r'[^\w]', '_', col.lower()).strip('_') for col in df.columns]
    df.columns = new_columns
    return df


DimDatedf = standardize_column_names(DimDatedf)
DimDatedf.head()

DimAppointmentdf = standardize_column_names(DimAppointmentdf)
DimAppointmentdf.head()

DimDoctordf = standardize_column_names(DimDoctordf)
DimDoctordf.head()

DimMedicalRecorddf = standardize_column_names(DimMedicalRecorddf)
DimMedicalRecorddf.head()

DimPrescriptiondf = standardize_column_names(DimPrescriptiondf)
DimPrescriptiondf.head()

DimPatientdf = standardize_column_names(DimPatientdf)
DimPatientdf.head()

FactPrescriptiondf = standardize_column_names(FactPrescriptiondf)
FactPrescriptiondf.head()


DimAppointmentdf.isnull().sum()

DimDatedf.isnull().sum()

DimDoctordf.isnull().sum()

DimMedicalRecorddf.isnull().sum()

DimPatientdf.isnull().sum()

DimPrescriptiondf.isnull().sum()

FactPrescriptiondf.isnull().sum()

# Optionally convert to string if you prefer it in a human-readable format
DimPatientdf['dob'] = DimPatientdf['dob'].astype(str)

# prompt: drop the rows with duplicate prescription_id

FactPrescriptiondf = FactPrescriptiondf.drop_duplicates(subset=['prescription_id'])

# Verify that duplicates have been dropped
duplicate_prescription_ids_after_drop = FactPrescriptiondf[FactPrescriptiondf.duplicated(subset=['prescription_id'], keep=False)]

if not duplicate_prescription_ids_after_drop.empty:
    print("Duplicates still found in FactPrescriptiondf for 'prescription_id':")
    print(duplicate_prescription_ids_after_drop)
else:
    print("No duplicates found for 'prescription_id' in FactPrescriptiondf after dropping.")

print(FactPrescriptiondf.head())

print(DimPatientdf.head())

DimMedicalRecorddf['treatment'] = DimMedicalRecorddf['treatment'].replace('NA', 'N/A')

DimAppointmentdf = DimAppointmentdf.drop(columns=['appointment_date'])
DimAppointmentdf.head()


import pandas as pd
import snowflake.connector
from snowflake.connector.pandas_tools import write_pandas

# Snowflake connection
conn = snowflake.connector.connect(
    user='#',
    password='#',
    account='#',
    warehouse='PROJECT_WAREHOUSE',
    database='HOSPITAL_PRESCRIPTIONS',
    schema='STARSCHEMA'
)

# Upload each DataFrame to its respective table
write_pandas(conn,DimAppointmentdf,'DimAppointment',schema='STARSCHEMA')
write_pandas(conn, DimDatedf, 'DimDate',overwrite=True, schema='STARSCHEMA')
write_pandas(conn, DimDoctordf, 'DimDoctor', overwrite=True,schema='STARSCHEMA')
write_pandas(conn, DimMedicalRecorddf, 'DimMedicalRecord',schema='STARSCHEMA')
write_pandas(conn, DimPrescriptiondf, 'DimPrescription',schema='STARSCHEMA')
write_pandas(conn, DimPatientdf, 'DimPatient',schema='STARSCHEMA')
write_pandas(conn, FactPrescriptiondf, 'FactPrescription',schema='STARSCHEMA')